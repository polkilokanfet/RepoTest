<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\HVTApp.Model\bin\Debug\HVTApp.Infrastructure.dll" #>
<#@ assembly name="$(SolutionDir)\HVTApp.Model\bin\Debug\HVTApp.Model.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="HVTApp.Model.POCOs" #>
<#@ import namespace="HVTApp.Infrastructure" #>
<#@ output extension=".cs" #>
<#
  //foreach (var modelType in GetModelTypes())
  //{
	//GenerateWrapper(modelType);
	//SaveGeneratedCodeAsFile(modelType.Name + "Wrapper.g.cs", "Wrapper/Generated");
  //	
	//GenerateLookup(modelType);
	//SaveGeneratedCodeAsFile(modelType.Name + "Lookup.g.cs", "Lookup/Items/Generated");
  //
	//GenerateLookupDataServiceInterface(modelType);
	//SaveGeneratedCodeAsFile("I" + modelType.Name + "LookupDataService.g.cs", "Lookup/Service/Interfaces");
  //
	//GenerateLookupDataService(modelType);
	//SaveGeneratedCodeAsFile(modelType.Name + "LookupDataService.g.cs", "Lookup/Service/Generated");
  //
	//GenerateAfterSaveEntityEvent(modelType);
	//SaveGeneratedCodeAsFile("AfterSave" + modelType.Name + "Event.g.cs", "Events/AfterSaveEntityEvents");
  //
	//GenerateAfterRemoveEntityEvent(modelType);
	//SaveGeneratedCodeAsFile("AfterRemove" + modelType.Name + "Event.g.cs", "Events/AfterRemoveEntityEvents");
  //}

	var modelTypes = GetModelTypes();

    GenerateWrappers(modelTypes);
	SaveGeneratedCodeAsFile("Wrappers.g.cs", "Wrapper");

	GenerateLookups(modelTypes);
	SaveGeneratedCodeAsFile("Lookups.g.cs", "Lookup/Items");

	GenerateLookupDataServiceInterfaces(modelTypes);
	SaveGeneratedCodeAsFile("ILookupDataServices.g.cs", "Lookup/Service");

	GenerateLookupDataServices(modelTypes);
	SaveGeneratedCodeAsFile("LookupDataServices.g.cs", "Lookup/Service");

	GenerateEntityWrapperDataServices(modelTypes);
	SaveGeneratedCodeAsFile("EntityWrapperDataServices.g.cs", "Wrapper/DataService");

	GenerateWrapperDataService(modelTypes);
	SaveGeneratedCodeAsFile("WrapperDataService.g.cs", "Wrapper/DataService");

    GenerateListViewModels(modelTypes);
	SaveGeneratedCodeAsFile("GeneratedListViewModels.g.cs", "ViewModels/List");

    GenerateDetailsViewModels(modelTypes);
	SaveGeneratedCodeAsFile("GeneratedDetailsViewModels.g.cs", "ViewModels/Details");

	GenerateAfterSaveEntityEvents(modelTypes);
	SaveGeneratedCodeAsFile("AfterSaveEntityEvents.g.cs", "Events/AfterSaveEntityEvents");

	GenerateAfterRemoveEntityEvents(modelTypes);
	SaveGeneratedCodeAsFile("AfterRemoveEntityEvents.g.cs", "Events/AfterRemoveEntityEvents");

	GenerateListViews(modelTypes);
	SaveGeneratedCodeAsFile("ListViews.g.cs", "Views/List");
#>

<#+

    private void GenerateLookups(IEnumerable<Type> modelTypes)
    {
#>namespace HVTApp.UI.Lookup
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateLookup(modelType);
        }
#>}
<#+
    }

	private void GenerateLookup(Type modelType)
	{
#>
	public partial class <#=modelType.Name#>Lookup : LookupItem { }
<#+
	}


    private void GenerateLookupDataServiceInterfaces(IEnumerable<Type> modelTypes)
    {
#>namespace HVTApp.UI.Lookup
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateLookupDataServiceInterface(modelType);
        }
#>}
<#+
    }

	private void GenerateLookupDataServiceInterface(Type modelType)
	{
#>	public interface I<#=modelType.Name#>LookupDataService : ILookupDataService<<#=modelType.Name#>Lookup> { } 
<#+
	}


    private void GenerateLookupDataServices(IEnumerable<Type> modelTypes)
    {
#>using System;
using HVTApp.DataAccess;
using HVTApp.Model.POCOs;

namespace HVTApp.UI.Lookup
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateLookupDataService(modelType);
        }
#>}
<#+
    }

	private void GenerateLookupDataService(Type modelType)
	{
#>
    public partial class <#=modelType.Name#>LookupDataService : LookupDataService<<#=modelType.Name#>Lookup, <#=modelType.Name#>>, I<#=modelType.Name#>LookupDataService
    {
        public <#=modelType.Name#>LookupDataService(HvtAppContext context) : base(context) { }
    }

<#+
	}

    private void GenerateListViewModels(IEnumerable<Type> modelTypes)
	{
#>using HVTApp.Model.POCOs;
using HVTApp.UI.Events;
using HVTApp.UI.Wrapper;
using Microsoft.Practices.Unity;

namespace HVTApp.UI.ViewModels
{
<#+
        foreach(var modelType in modelTypes)
        {
#>
    public partial class <#=modelType.Name#>ListViewModel : BaseWrapperListViewModel<<#=modelType.Name#>Wrapper, <#=modelType.Name#>, <#=modelType.Name#>DetailsViewModel, AfterSave<#=modelType.Name#>Event>
    {
        public <#=modelType.Name#>ListViewModel(IUnityContainer container, <#=modelType.Name#>WrapperDataService wrapperDataService) : base(container, wrapperDataService) { }
    }

<#+
        }
#>
}
<#+
	}

    private void GenerateDetailsViewModels(IEnumerable<Type> modelTypes)
	{
#>using HVTApp.Model.POCOs;
using HVTApp.UI.Events;
using HVTApp.UI.Wrapper;
using Microsoft.Practices.Unity;

namespace HVTApp.UI.ViewModels
{
<#+
        foreach(var modelType in modelTypes)
        {
#>
    public partial class <#=modelType.Name#>DetailsViewModel : BaseDetailsViewModel<<#=modelType.Name#>Wrapper, <#=modelType.Name#>, AfterSave<#=modelType.Name#>Event>
    {
        public <#=modelType.Name#>DetailsViewModel(IUnityContainer container) : base(container) { }
    }

<#+
        }
#>
}
<#+
	}

	private void GenerateEntityWrapperDataServices(IEnumerable<Type> modelTypes)
	{
#>using System.Linq;
using HVTApp.DataAccess;
using HVTApp.Model.POCOs;

namespace HVTApp.UI.Wrapper
{
<#+
        foreach(var modelType in modelTypes)
        {
 #>
    public partial class <#=modelType.Name#>WrapperDataService : EntityWrapperDataService<<#=modelType.Name#>, <#=modelType.Name#>Wrapper>
    {
        public <#=modelType.Name#>WrapperDataService(IUnitOfWork unitOfWork) : base(unitOfWork) { }
		
		protected override <#=modelType.Name#>Wrapper GenerateWrapper(<#=modelType.Name#> model)
        {
            if (ExistsWrappers.Any(x => x.Model.Id == model.Id))
                return ExistsWrappers.Single(x => x.Model.Id == model.Id);

            var wrapper = new <#=modelType.Name#>Wrapper(model);
            ExistsWrappers.Add(wrapper);
            return wrapper;
        }
    }

<#+
        }
 #>
}
<#+
	}

	private void GenerateWrapperDataService(IEnumerable<Type> modelTypes)
	{
#>using HVTApp.DataAccess;

namespace HVTApp.UI.Wrapper
{
    public partial class WrapperDataService
    {
        public WrapperDataService(IUnitOfWork unitOfWork)
        {
<#+
        foreach(var modelType in modelTypes)
        {
#>
            <#=modelType.Name#>WrapperDataService = new <#=modelType.Name#>WrapperDataService(unitOfWork);
<#+
        }
#>
        }

<#+
        foreach(var modelType in modelTypes)
        {
#>
        public <#=modelType.Name#>WrapperDataService <#=modelType.Name#>WrapperDataService { get; }
<#+
        }
#>
    }
}
<#+
	}


    private void GenerateAfterSaveEntityEvents(IEnumerable<Type> modelTypes)
    {
#>using HVTApp.Model.POCOs;
using Prism.Events;

namespace HVTApp.UI.Events
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateAfterSaveEntityEvent(modelType);
        }
#>}
<#+
    }

	private void GenerateAfterSaveEntityEvent(Type modelType)
	{
#>	public partial class AfterSave<#=modelType.Name#>Event : PubSubEvent<<#=modelType.Name#>> { }
<#+
	}


    private void GenerateAfterRemoveEntityEvents(IEnumerable<Type> modelTypes)
    {
#>using HVTApp.Model.POCOs;
using Prism.Events;

namespace HVTApp.UI.Events
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateAfterRemoveEntityEvent(modelType);
        }
#>}
<#+
    }

	private void GenerateAfterRemoveEntityEvent(Type modelType)
	{
#>	public partial class AfterRemove<#=modelType.Name#>Event : PubSubEvent<<#=modelType.Name#>> { }
<#+
	}


	private void GenerateListViews(IEnumerable<Type> modelTypes)
	{
#>using HVTApp.Infrastructure;
using HVTApp.UI.Tabs;
using Prism.Events;
using Prism.Regions;

namespace HVTApp.UI.Views
{
<#+
        foreach(var modelType in modelTypes)
        {
 #>
    [RibbonTab(typeof(TabCRUD))]
    public partial class <#=modelType.Name#>ListView //: ViewBase
    {
        //public <#=modelType.Name#>ListView(IRegionManager regionManager, IEventAggregator eventAggregator) : base(regionManager, eventAggregator)
        //{
        //    InitializeComponent();
        //}
    }

<#+
        }
 #>
}
<#+
	}

    private void GenerateWrappers(IEnumerable<Type> modelTypes)
    {
#>using System;
using System.Linq;
using HVTApp.Model.POCOs;

namespace HVTApp.UI.Wrapper
{
<#+
        foreach(var modelType in modelTypes)
        {
            GenerateWrapper(modelType);
        }
#>}
<#+
    }

	private void GenerateWrapper(Type modelType)
	{
		var allProperties = modelType.GetProperties();


		//Простые свойства
		var allSimpleProperties = allProperties.Where(p => IsSimple(p.PropertyType));

		var simpleSetProperties = allSimpleProperties.Where(p => p.CanWrite).ToList();
		var simpleGetProperties = allSimpleProperties.Where(p => !p.CanWrite).ToList();

		//Перечисления
		var allCollectionProperties = allProperties.Except(allSimpleProperties)
				.Where(p => p.PropertyType.GetInterfaces()
				.Any(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(ICollection<>)));

		var collectionComplexProperties = allCollectionProperties.Where(x => !CollectionMemberTypeIsSimple(x.PropertyType)).ToList();

		//Сложные свойства
		//var allComplexProperties = allProperties.Except(simpleProperties).Where(p => p.PropertyType.IsClass && !typeof(IEnumerable).IsAssignableFrom(p.PropertyType));
		var allComplexProperties = allProperties.Except(allSimpleProperties).Except(allCollectionProperties);

		var complexSetProperties = allComplexProperties.Where(p => p.CanWrite).ToList();
		var complexGetProperties = allComplexProperties.Where(p => !p.CanWrite).ToList();

#>	public partial class <#=modelType.Name#>Wrapper : WrapperBase<<#=modelType.Name#>>
	{
	    public <#=modelType.Name#>Wrapper(<#=modelType.Name#> model) : base(model) { }

	<#+
		GenerateSimpleProperties(simpleSetProperties);
		GenerateComplexProperties(complexSetProperties);
		GenerateCollectionComplexProperties(collectionComplexProperties);

		GenerateGetProperties(simpleGetProperties.Union(complexGetProperties));

		GenerateInitializeComplexProperties(modelType.Name, complexSetProperties);
		GenerateInitializeCollectionComplexProperties(modelType.Name, collectionComplexProperties);
	#>
	}

	<#+
	}
	
    //берем все классы модели.
    private IEnumerable<Type> GetModelTypes()
    {
        var ns = typeof(Address).Namespace;
        //return typeof(Address).Assembly.GetTypes().Where(x => !x.IsAbstract && !x.IsEnum && x.Namespace == ns && !x.Name.Contains("<"));
        return typeof(Address).Assembly.GetTypes().Where(x => GetBaseTypes(x).Contains(typeof(BaseEntity)));
    }
    
	    IEnumerable<Type> GetBaseTypes(Type type)
        {
            List<Type> result = new List<Type>();
            while (type.BaseType != null)
            {
                result.Add(type.BaseType);
                type = type.BaseType;
            }
            return result;
        }


    //тип простой
    private bool IsSimple(Type type)
    {
        return type.IsValueType || type.IsValueType || type == typeof (string);
    }

    //коллекция простых типов?
    private bool CollectionMemberTypeIsSimple(Type genericCollectionType)
    {
        var tt = genericCollectionType.GetInterfaces();
        var t = genericCollectionType.GetInterfaces()
            .First(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof (ICollection<>))
            .GetGenericArguments()[0];

        return IsSimple(t);
    }
    
    //сохранение сгенерированного кода в отдельный файл.
    private void SaveGeneratedCodeAsFile(string fileName, string filePath)
    {
		string directoryName = Path.GetDirectoryName(Host.TemplateFile);
        string dir = Path.Combine(directoryName, filePath);
  
        string outputFilePath = Path.Combine(dir, fileName);
        File.WriteAllText(outputFilePath, GenerationEnvironment.ToString()); 
 
        GenerationEnvironment.Clear();
    }

    //возвращаем имя типа
    private string GetTypeName(Type type)
    {
        if (type.IsGenericType)
        {
            var genericArguments = type.GetGenericArguments().Select(t => GetTypeName(t)).ToArray();
            var typeDefinition = type.GetGenericTypeDefinition().FullName;
            typeDefinition = typeDefinition.Substring(0, typeDefinition.IndexOf('`'));
            return string.Format("{0}<{1}>", typeDefinition, string.Join(",", genericArguments));
        }
        else
        {
            return type.FullName;
        }
    }

  //генерация свойств простых типов.
  private void GenerateSimpleProperties(IEnumerable<PropertyInfo> properties)
  {
  	if (!properties.Any())
		return;
#>

        #region SimpleProperties
<#+ 
    foreach (var property in properties)
    {
      var propertyType = GetTypeName(property.PropertyType);
      var propertyName = property.Name;
#>
        public <#=propertyType#> <#=propertyName#>
        {
          get { return GetValue<<#=propertyType#>>(); }
          set { SetValue(value); }
        }
        public <#=propertyType#> <#=propertyName#>OriginalValue => GetOriginalValue<<#=propertyType#>>(nameof(<#=propertyName#>));
        public bool <#=propertyName#>IsChanged => GetIsChanged(nameof(<#=propertyName#>));

<#+ 
    }
#>
        #endregion
<#+
  }

  //генерация свойств доступных только для чтения.
  private void GenerateGetProperties(IEnumerable<PropertyInfo> properties)
  {
  	if (!properties.Any())
		return;
#>

        #region GetProperties
<#+ 
    foreach (var property in properties)
    {
      var propertyType = GetTypeName(property.PropertyType);
      var propertyName = property.Name;
#>
        public <#=propertyType#> <#=propertyName#> => GetValue<<#=propertyType#>>(); 

<#+
    }
#>
        #endregion
<#+
  }

  //генрация свойств сложных типов
  private void GenerateComplexProperties(IEnumerable<PropertyInfo> properties)
  {
  	if (!properties.Any())
		return;
#>

        #region ComplexProperties
<#+ 

    foreach (var property in properties)
    {
      var propertyType = property.PropertyType.Name;
      var propertyName = property.Name;
#>
	    public <#= propertyType #>Wrapper <#= propertyName #> 
        {
            get { return GetWrapper<<#= propertyType #>Wrapper>(); }
            set { SetComplexValue<<#= propertyType #>, <#= propertyType #>Wrapper>(<#= propertyName #>, value); }
        }

<#+   
    }
#>
        #endregion
<#+
  }

  //генерация свойств-коллекций.
  private void GenerateCollectionComplexProperties(IEnumerable<PropertyInfo> properties)
  {
  	if (!properties.Any())
		return;
#>

        #region CollectionProperties
<#+ 

    foreach (var property in properties)
    {
      var itemType = property.PropertyType.GetInterfaces().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(ICollection<>)).GenericTypeArguments[0].Name;
      var propertyName = property.Name;
#>
        public IValidatableChangeTrackingCollection<<#= itemType #>Wrapper> <#= propertyName #> { get; private set; }

<#+  
    }
#>
        #endregion
<#+
  }

  //инициализация сложных свойств
  private void GenerateInitializeComplexProperties(string modelTypeName, IEnumerable<PropertyInfo> properties)
  {
    if(properties.Any())
    {
#>
        public override void InitializeComplexProperties()
        {
<#+
	  foreach (var complexProperty in properties)
      {
		var propertyName = complexProperty.Name;
		var propertyType = complexProperty.PropertyType.Name;
#>
            InitializeComplexProperty<<#= propertyType #>Wrapper>(nameof(<#= propertyName #>), Model.<#= propertyName #> == null ? null : new <#= propertyType #>Wrapper(Model.<#= propertyName #>));

<#+
      }
#>
        }
<#+
    }
  }

  //инициализация коллекций
  private void GenerateInitializeCollectionComplexProperties(string modelTypeName, IEnumerable<System.Reflection.PropertyInfo> properties)
  {
    if(properties.Any())
    {
#>
  
        protected override void InitializeCollectionProperties()
        {
<#+
      foreach(var property in properties)
      {
		var itemType = property.PropertyType.GetInterfaces().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(ICollection<>)).GenericTypeArguments[0].Name;
		var propertyName = property.Name;
		   
#>
          if (Model.<#= propertyName #> == null) throw new ArgumentException("<#= propertyName #> cannot be null");
          <#= propertyName #> = new ValidatableChangeTrackingCollection<<#= itemType #>Wrapper>(Model.<#= propertyName #>.Select(e => new <#= itemType #>Wrapper(e)));
          RegisterCollection(<#= propertyName #>, Model.<#= propertyName #>);

<#+
     }
#>
        }
<#+
    }
  }
#>